#ifndef TSG_BASE_HEX_HPP
#define TSG_BASE_HEX_HPP

// see https://github.com/zbjornson/fast-hex
// see https://stackoverflow.com/questions/3408706/hexadecimal-String-to-byte-Array-in-c
// see https://stackoverflow.com/questions/14050452/how-to-convert-byte-Array-to-hex-String-in-visual-c
#include <cstring>

namespace tsg {
namespace hex {

using Byte = unsigned char;

constexpr static const char characters_upper_case[16] = //
    {'0', '1', '2', '3', '4', '5', '6', '7',            //
     '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};           //

constexpr static const char characters_lower_case[16] = //
    {'0', '1', '2', '3', '4', '5', '6', '7',            //
     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};           //

constexpr static const Byte ascii_to_hex_map[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //  !"#$%&'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ()*+,-./
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // 01234567
    0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 89:;<=>?
    0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // @ABCDEFG
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // HIJKLMNO
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PQRSTUVW
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XYZ[\]^_
    0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // `abcdefg
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // hijklmno
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pqrstuvw
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xyz{|}~.
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // ........
};

constexpr static void hex_string_of(Byte byte, char &first, char &second, bool upper_case = false) {
    const char *characters = upper_case ? characters_upper_case : characters_lower_case;
    first = characters[byte >> 4];
    second = characters[byte & 0x0F];
}

constexpr static void hex_string_of(Byte *bytes, size_t bytes_size, char *str, size_t str_size,
                                    bool upper_case = false) {
    size_t str_count = 0;
    for (size_t i = 0; i < bytes_size; i++) {
        hex_string_of(bytes[i], str[str_count], str[str_count + 1], upper_case);
        str_count += 2;
    }
}

constexpr static void byte_array_of(const char *str, Byte *bytes, size_t bytes_size) {
    for (unsigned char pos = 0; ((pos < (bytes_size * 2)) && (pos < strlen(str))); pos += 2) {
        Byte first = (Byte)str[pos + 0];
        Byte second = (Byte)str[pos + 1];
        bytes[pos / 2] = (Byte)(ascii_to_hex_map[first] << 4) | ascii_to_hex_map[second];
    };
}

} // namespace hex
} // namespace tsg

#endif // TSG_BASE_HEX_HPP
